<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 12.3 - src/include/nodes/pg_list.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/include/nodes</a> - pg_list.h<span style="font-size: 80%;"> (source / <a href="pg_list.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 12.3</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-07-01 02:50:32</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * pg_list.h
<span class="lineNum">       4 </span>            :  *    interface for PostgreSQL generic linked list package
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * This package implements singly-linked homogeneous lists.
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * It is important to have constant-time length, append, and prepend
<span class="lineNum">       9 </span>            :  * operations. To achieve this, we deal with two distinct data
<span class="lineNum">      10 </span>            :  * structures:
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  *      1. A set of &quot;list cells&quot;: each cell contains a data field and
<span class="lineNum">      13 </span>            :  *         a link to the next cell in the list or NULL.
<span class="lineNum">      14 </span>            :  *      2. A single structure containing metadata about the list: the
<span class="lineNum">      15 </span>            :  *         type of the list, pointers to the head and tail cells, and
<span class="lineNum">      16 </span>            :  *         the length of the list.
<span class="lineNum">      17 </span>            :  *
<span class="lineNum">      18 </span>            :  * We support three types of lists:
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  *  T_List: lists of pointers
<span class="lineNum">      21 </span>            :  *      (in practice usually pointers to Nodes, but not always;
<span class="lineNum">      22 </span>            :  *      declared as &quot;void *&quot; to minimize casting annoyances)
<span class="lineNum">      23 </span>            :  *  T_IntList: lists of integers
<span class="lineNum">      24 </span>            :  *  T_OidList: lists of Oids
<span class="lineNum">      25 </span>            :  *
<span class="lineNum">      26 </span>            :  * (At the moment, ints and Oids are the same size, but they may not
<span class="lineNum">      27 </span>            :  * always be so; try to be careful to maintain the distinction.)
<span class="lineNum">      28 </span>            :  *
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">      31 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * src/include/nodes/pg_list.h
<span class="lineNum">      34 </span>            :  *
<span class="lineNum">      35 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      36 </span>            :  */
<span class="lineNum">      37 </span>            : #ifndef PG_LIST_H
<span class="lineNum">      38 </span>            : #define PG_LIST_H
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #include &quot;nodes/nodes.h&quot;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : typedef struct ListCell ListCell;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : typedef struct List
<span class="lineNum">      46 </span>            : {
<span class="lineNum">      47 </span>            :     NodeTag     type;           /* T_List, T_IntList, or T_OidList */
<span class="lineNum">      48 </span>            :     int         length;
<span class="lineNum">      49 </span>            :     ListCell   *head;
<span class="lineNum">      50 </span>            :     ListCell   *tail;
<span class="lineNum">      51 </span>            : } List;
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : struct ListCell
<span class="lineNum">      54 </span>            : {
<span class="lineNum">      55 </span>            :     union
<span class="lineNum">      56 </span>            :     {
<span class="lineNum">      57 </span>            :         void       *ptr_value;
<span class="lineNum">      58 </span>            :         int         int_value;
<span class="lineNum">      59 </span>            :         Oid         oid_value;
<span class="lineNum">      60 </span>            :     }           data;
<span class="lineNum">      61 </span>            :     ListCell   *next;
<span class="lineNum">      62 </span>            : };
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : /*
<span class="lineNum">      65 </span>            :  * The *only* valid representation of an empty list is NIL; in other
<span class="lineNum">      66 </span>            :  * words, a non-NIL list is guaranteed to have length &gt;= 1 and
<span class="lineNum">      67 </span>            :  * head/tail != NULL
<span class="lineNum">      68 </span>            :  */
<span class="lineNum">      69 </span>            : #define NIL                     ((List *) NULL)
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : /*
<span class="lineNum">      72 </span>            :  * These routines are used frequently. However, we can't implement
<span class="lineNum">      73 </span>            :  * them as macros, since we want to avoid double-evaluation of macro
<span class="lineNum">      74 </span>            :  * arguments.
<a name="75"><span class="lineNum">      75 </span>            :  */</a>
<span class="lineNum">      76 </span>            : static inline ListCell *
<span class="lineNum">      77 </span><span class="lineCov">       6222 : list_head(const List *l)</span>
<span class="lineNum">      78 </span>            : {
<span class="lineNum">      79 </span><span class="lineCov">       6222 :     return l ? l-&gt;head : NULL;</span>
<span class="lineNum">      80 </span>            : }
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : static inline ListCell *
<span class="lineNum">      83 </span>            : list_tail(List *l)
<span class="lineNum">      84 </span>            : {
<span class="lineNum">      85 </span>            :     return l ? l-&gt;tail : NULL;
<span class="lineNum">      86 </span>            : }
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : static inline int
<span class="lineNum">      89 </span>            : list_length(const List *l)
<span class="lineNum">      90 </span>            : {
<span class="lineNum">      91 </span>            :     return l ? l-&gt;length : 0;
<span class="lineNum">      92 </span>            : }
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : /*
<span class="lineNum">      95 </span>            :  * NB: There is an unfortunate legacy from a previous incarnation of
<span class="lineNum">      96 </span>            :  * the List API: the macro lfirst() was used to mean &quot;the data in this
<span class="lineNum">      97 </span>            :  * cons cell&quot;. To avoid changing every usage of lfirst(), that meaning
<span class="lineNum">      98 </span>            :  * has been kept. As a result, lfirst() takes a ListCell and returns
<span class="lineNum">      99 </span>            :  * the data it contains; to get the data in the first cell of a
<span class="lineNum">     100 </span>            :  * List, use linitial(). Worse, lsecond() is more closely related to
<span class="lineNum">     101 </span>            :  * linitial() than lfirst(): given a List, lsecond() returns the data
<span class="lineNum">     102 </span>            :  * in the second cons cell.
<span class="lineNum">     103 </span>            :  */
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : #define lnext(lc)               ((lc)-&gt;next)
<span class="lineNum">     106 </span>            : #define lfirst(lc)              ((lc)-&gt;data.ptr_value)
<span class="lineNum">     107 </span>            : #define lfirst_int(lc)          ((lc)-&gt;data.int_value)
<span class="lineNum">     108 </span>            : #define lfirst_oid(lc)          ((lc)-&gt;data.oid_value)
<span class="lineNum">     109 </span>            : #define lfirst_node(type,lc)    castNode(type, lfirst(lc))
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : #define linitial(l)             lfirst(list_head(l))
<span class="lineNum">     112 </span>            : #define linitial_int(l)         lfirst_int(list_head(l))
<span class="lineNum">     113 </span>            : #define linitial_oid(l)         lfirst_oid(list_head(l))
<span class="lineNum">     114 </span>            : #define linitial_node(type,l)   castNode(type, linitial(l))
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : #define lsecond(l)              lfirst(lnext(list_head(l)))
<span class="lineNum">     117 </span>            : #define lsecond_int(l)          lfirst_int(lnext(list_head(l)))
<span class="lineNum">     118 </span>            : #define lsecond_oid(l)          lfirst_oid(lnext(list_head(l)))
<span class="lineNum">     119 </span>            : #define lsecond_node(type,l)    castNode(type, lsecond(l))
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : #define lthird(l)               lfirst(lnext(lnext(list_head(l))))
<span class="lineNum">     122 </span>            : #define lthird_int(l)           lfirst_int(lnext(lnext(list_head(l))))
<span class="lineNum">     123 </span>            : #define lthird_oid(l)           lfirst_oid(lnext(lnext(list_head(l))))
<span class="lineNum">     124 </span>            : #define lthird_node(type,l)     castNode(type, lthird(l))
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : #define lfourth(l)              lfirst(lnext(lnext(lnext(list_head(l)))))
<span class="lineNum">     127 </span>            : #define lfourth_int(l)          lfirst_int(lnext(lnext(lnext(list_head(l)))))
<span class="lineNum">     128 </span>            : #define lfourth_oid(l)          lfirst_oid(lnext(lnext(lnext(list_head(l)))))
<span class="lineNum">     129 </span>            : #define lfourth_node(type,l)    castNode(type, lfourth(l))
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : #define llast(l)                lfirst(list_tail(l))
<span class="lineNum">     132 </span>            : #define llast_int(l)            lfirst_int(list_tail(l))
<span class="lineNum">     133 </span>            : #define llast_oid(l)            lfirst_oid(list_tail(l))
<span class="lineNum">     134 </span>            : #define llast_node(type,l)      castNode(type, llast(l))
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : /*
<span class="lineNum">     137 </span>            :  * Convenience macros for building fixed-length lists
<span class="lineNum">     138 </span>            :  */
<span class="lineNum">     139 </span>            : #define list_make1(x1)              lcons(x1, NIL)
<span class="lineNum">     140 </span>            : #define list_make2(x1,x2)           lcons(x1, list_make1(x2))
<span class="lineNum">     141 </span>            : #define list_make3(x1,x2,x3)        lcons(x1, list_make2(x2, x3))
<span class="lineNum">     142 </span>            : #define list_make4(x1,x2,x3,x4)     lcons(x1, list_make3(x2, x3, x4))
<span class="lineNum">     143 </span>            : #define list_make5(x1,x2,x3,x4,x5)  lcons(x1, list_make4(x2, x3, x4, x5))
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : #define list_make1_int(x1)          lcons_int(x1, NIL)
<span class="lineNum">     146 </span>            : #define list_make2_int(x1,x2)       lcons_int(x1, list_make1_int(x2))
<span class="lineNum">     147 </span>            : #define list_make3_int(x1,x2,x3)    lcons_int(x1, list_make2_int(x2, x3))
<span class="lineNum">     148 </span>            : #define list_make4_int(x1,x2,x3,x4) lcons_int(x1, list_make3_int(x2, x3, x4))
<span class="lineNum">     149 </span>            : #define list_make5_int(x1,x2,x3,x4,x5)  lcons_int(x1, list_make4_int(x2, x3, x4, x5))
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : #define list_make1_oid(x1)          lcons_oid(x1, NIL)
<span class="lineNum">     152 </span>            : #define list_make2_oid(x1,x2)       lcons_oid(x1, list_make1_oid(x2))
<span class="lineNum">     153 </span>            : #define list_make3_oid(x1,x2,x3)    lcons_oid(x1, list_make2_oid(x2, x3))
<span class="lineNum">     154 </span>            : #define list_make4_oid(x1,x2,x3,x4) lcons_oid(x1, list_make3_oid(x2, x3, x4))
<span class="lineNum">     155 </span>            : #define list_make5_oid(x1,x2,x3,x4,x5)  lcons_oid(x1, list_make4_oid(x2, x3, x4, x5))
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : /*
<span class="lineNum">     158 </span>            :  * foreach -
<span class="lineNum">     159 </span>            :  *    a convenience macro which loops through the list
<span class="lineNum">     160 </span>            :  */
<span class="lineNum">     161 </span>            : #define foreach(cell, l)    \
<span class="lineNum">     162 </span>            :     for ((cell) = list_head(l); (cell) != NULL; (cell) = lnext(cell))
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /*
<span class="lineNum">     165 </span>            :  * for_each_cell -
<span class="lineNum">     166 </span>            :  *    a convenience macro which loops through a list starting from a
<span class="lineNum">     167 </span>            :  *    specified cell
<span class="lineNum">     168 </span>            :  */
<span class="lineNum">     169 </span>            : #define for_each_cell(cell, initcell)   \
<span class="lineNum">     170 </span>            :     for ((cell) = (initcell); (cell) != NULL; (cell) = lnext(cell))
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : /*
<span class="lineNum">     173 </span>            :  * forboth -
<span class="lineNum">     174 </span>            :  *    a convenience macro for advancing through two linked lists
<span class="lineNum">     175 </span>            :  *    simultaneously. This macro loops through both lists at the same
<span class="lineNum">     176 </span>            :  *    time, stopping when either list runs out of elements. Depending
<span class="lineNum">     177 </span>            :  *    on the requirements of the call site, it may also be wise to
<span class="lineNum">     178 </span>            :  *    assert that the lengths of the two lists are equal.
<span class="lineNum">     179 </span>            :  */
<span class="lineNum">     180 </span>            : #define forboth(cell1, list1, cell2, list2)                         \
<span class="lineNum">     181 </span>            :     for ((cell1) = list_head(list1), (cell2) = list_head(list2);    \
<span class="lineNum">     182 </span>            :          (cell1) != NULL &amp;&amp; (cell2) != NULL;                        \
<span class="lineNum">     183 </span>            :          (cell1) = lnext(cell1), (cell2) = lnext(cell2))
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : /*
<span class="lineNum">     186 </span>            :  * for_both_cell -
<span class="lineNum">     187 </span>            :  *    a convenience macro which loops through two lists starting from the
<span class="lineNum">     188 </span>            :  *    specified cells of each. This macro loops through both lists at the same
<span class="lineNum">     189 </span>            :  *    time, stopping when either list runs out of elements.  Depending on the
<span class="lineNum">     190 </span>            :  *    requirements of the call site, it may also be wise to assert that the
<span class="lineNum">     191 </span>            :  *    lengths of the two lists are equal, and initcell1 and initcell2 are at
<span class="lineNum">     192 </span>            :  *    the same position in the respective lists.
<span class="lineNum">     193 </span>            :  */
<span class="lineNum">     194 </span>            : #define for_both_cell(cell1, initcell1, cell2, initcell2)   \
<span class="lineNum">     195 </span>            :     for ((cell1) = (initcell1), (cell2) = (initcell2);      \
<span class="lineNum">     196 </span>            :          (cell1) != NULL &amp;&amp; (cell2) != NULL;                \
<span class="lineNum">     197 </span>            :          (cell1) = lnext(cell1), (cell2) = lnext(cell2))
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : /*
<span class="lineNum">     200 </span>            :  * forthree -
<span class="lineNum">     201 </span>            :  *    the same for three lists
<span class="lineNum">     202 </span>            :  */
<span class="lineNum">     203 </span>            : #define forthree(cell1, list1, cell2, list2, cell3, list3)          \
<span class="lineNum">     204 </span>            :     for ((cell1) = list_head(list1), (cell2) = list_head(list2), (cell3) = list_head(list3); \
<span class="lineNum">     205 </span>            :          (cell1) != NULL &amp;&amp; (cell2) != NULL &amp;&amp; (cell3) != NULL;     \
<span class="lineNum">     206 </span>            :          (cell1) = lnext(cell1), (cell2) = lnext(cell2), (cell3) = lnext(cell3))
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : /*
<span class="lineNum">     209 </span>            :  * forfour -
<span class="lineNum">     210 </span>            :  *    the same for four lists
<span class="lineNum">     211 </span>            :  */
<span class="lineNum">     212 </span>            : #define forfour(cell1, list1, cell2, list2, cell3, list3, cell4, list4) \
<span class="lineNum">     213 </span>            :     for ((cell1) = list_head(list1), (cell2) = list_head(list2), \
<span class="lineNum">     214 </span>            :          (cell3) = list_head(list3), (cell4) = list_head(list4); \
<span class="lineNum">     215 </span>            :          (cell1) != NULL &amp;&amp; (cell2) != NULL &amp;&amp; \
<span class="lineNum">     216 </span>            :          (cell3) != NULL &amp;&amp; (cell4) != NULL; \
<span class="lineNum">     217 </span>            :          (cell1) = lnext(cell1), (cell2) = lnext(cell2), \
<span class="lineNum">     218 </span>            :          (cell3) = lnext(cell3), (cell4) = lnext(cell4))
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : /*
<span class="lineNum">     221 </span>            :  * forfive -
<span class="lineNum">     222 </span>            :  *    the same for five lists
<span class="lineNum">     223 </span>            :  */
<span class="lineNum">     224 </span>            : #define forfive(cell1, list1, cell2, list2, cell3, list3, cell4, list4, cell5, list5) \
<span class="lineNum">     225 </span>            :     for ((cell1) = list_head(list1), (cell2) = list_head(list2), \
<span class="lineNum">     226 </span>            :          (cell3) = list_head(list3), (cell4) = list_head(list4), \
<span class="lineNum">     227 </span>            :          (cell5) = list_head(list5); \
<span class="lineNum">     228 </span>            :          (cell1) != NULL &amp;&amp; (cell2) != NULL &amp;&amp; (cell3) != NULL &amp;&amp; \
<span class="lineNum">     229 </span>            :          (cell4) != NULL &amp;&amp; (cell5) != NULL; \
<span class="lineNum">     230 </span>            :          (cell1) = lnext(cell1), (cell2) = lnext(cell2), \
<span class="lineNum">     231 </span>            :          (cell3) = lnext(cell3), (cell4) = lnext(cell4), \
<span class="lineNum">     232 </span>            :          (cell5) = lnext(cell5))
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : extern List *lappend(List *list, void *datum);
<span class="lineNum">     235 </span>            : extern List *lappend_int(List *list, int datum);
<span class="lineNum">     236 </span>            : extern List *lappend_oid(List *list, Oid datum);
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            : extern ListCell *lappend_cell(List *list, ListCell *prev, void *datum);
<span class="lineNum">     239 </span>            : extern ListCell *lappend_cell_int(List *list, ListCell *prev, int datum);
<span class="lineNum">     240 </span>            : extern ListCell *lappend_cell_oid(List *list, ListCell *prev, Oid datum);
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : extern List *lcons(void *datum, List *list);
<span class="lineNum">     243 </span>            : extern List *lcons_int(int datum, List *list);
<span class="lineNum">     244 </span>            : extern List *lcons_oid(Oid datum, List *list);
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : extern List *list_concat(List *list1, List *list2);
<span class="lineNum">     247 </span>            : extern List *list_truncate(List *list, int new_size);
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : extern ListCell *list_nth_cell(const List *list, int n);
<span class="lineNum">     250 </span>            : extern void *list_nth(const List *list, int n);
<span class="lineNum">     251 </span>            : extern int  list_nth_int(const List *list, int n);
<span class="lineNum">     252 </span>            : extern Oid  list_nth_oid(const List *list, int n);
<span class="lineNum">     253 </span>            : #define list_nth_node(type,list,n)  castNode(type, list_nth(list, n))
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : extern bool list_member(const List *list, const void *datum);
<span class="lineNum">     256 </span>            : extern bool list_member_ptr(const List *list, const void *datum);
<span class="lineNum">     257 </span>            : extern bool list_member_int(const List *list, int datum);
<span class="lineNum">     258 </span>            : extern bool list_member_oid(const List *list, Oid datum);
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : extern List *list_delete(List *list, void *datum);
<span class="lineNum">     261 </span>            : extern List *list_delete_ptr(List *list, void *datum);
<span class="lineNum">     262 </span>            : extern List *list_delete_int(List *list, int datum);
<span class="lineNum">     263 </span>            : extern List *list_delete_oid(List *list, Oid datum);
<span class="lineNum">     264 </span>            : extern List *list_delete_first(List *list);
<span class="lineNum">     265 </span>            : extern List *list_delete_cell(List *list, ListCell *cell, ListCell *prev);
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : extern List *list_union(const List *list1, const List *list2);
<span class="lineNum">     268 </span>            : extern List *list_union_ptr(const List *list1, const List *list2);
<span class="lineNum">     269 </span>            : extern List *list_union_int(const List *list1, const List *list2);
<span class="lineNum">     270 </span>            : extern List *list_union_oid(const List *list1, const List *list2);
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : extern List *list_intersection(const List *list1, const List *list2);
<span class="lineNum">     273 </span>            : extern List *list_intersection_int(const List *list1, const List *list2);
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : /* currently, there's no need for list_intersection_ptr etc */
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : extern List *list_difference(const List *list1, const List *list2);
<span class="lineNum">     278 </span>            : extern List *list_difference_ptr(const List *list1, const List *list2);
<span class="lineNum">     279 </span>            : extern List *list_difference_int(const List *list1, const List *list2);
<span class="lineNum">     280 </span>            : extern List *list_difference_oid(const List *list1, const List *list2);
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : extern List *list_append_unique(List *list, void *datum);
<span class="lineNum">     283 </span>            : extern List *list_append_unique_ptr(List *list, void *datum);
<span class="lineNum">     284 </span>            : extern List *list_append_unique_int(List *list, int datum);
<span class="lineNum">     285 </span>            : extern List *list_append_unique_oid(List *list, Oid datum);
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : extern List *list_concat_unique(List *list1, List *list2);
<span class="lineNum">     288 </span>            : extern List *list_concat_unique_ptr(List *list1, List *list2);
<span class="lineNum">     289 </span>            : extern List *list_concat_unique_int(List *list1, List *list2);
<span class="lineNum">     290 </span>            : extern List *list_concat_unique_oid(List *list1, List *list2);
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            : extern void list_free(List *list);
<span class="lineNum">     293 </span>            : extern void list_free_deep(List *list);
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : extern List *list_copy(const List *list);
<span class="lineNum">     296 </span>            : extern List *list_copy_tail(const List *list, int nskip);
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : typedef int (*list_qsort_comparator) (const void *a, const void *b);
<span class="lineNum">     299 </span>            : extern List *list_qsort(const List *list, list_qsort_comparator cmp);
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : /*
<span class="lineNum">     302 </span>            :  * To ease migration to the new list API, a set of compatibility
<span class="lineNum">     303 </span>            :  * macros are provided that reduce the impact of the list API changes
<span class="lineNum">     304 </span>            :  * as far as possible. Until client code has been rewritten to use the
<span class="lineNum">     305 </span>            :  * new list API, the ENABLE_LIST_COMPAT symbol can be defined before
<span class="lineNum">     306 </span>            :  * including pg_list.h
<span class="lineNum">     307 </span>            :  */
<span class="lineNum">     308 </span>            : #ifdef ENABLE_LIST_COMPAT
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            : #define lfirsti(lc)                 lfirst_int(lc)
<span class="lineNum">     311 </span>            : #define lfirsto(lc)                 lfirst_oid(lc)
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : #define makeList1(x1)               list_make1(x1)
<span class="lineNum">     314 </span>            : #define makeList2(x1, x2)           list_make2(x1, x2)
<span class="lineNum">     315 </span>            : #define makeList3(x1, x2, x3)       list_make3(x1, x2, x3)
<span class="lineNum">     316 </span>            : #define makeList4(x1, x2, x3, x4)   list_make4(x1, x2, x3, x4)
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : #define makeListi1(x1)              list_make1_int(x1)
<span class="lineNum">     319 </span>            : #define makeListi2(x1, x2)          list_make2_int(x1, x2)
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            : #define makeListo1(x1)              list_make1_oid(x1)
<span class="lineNum">     322 </span>            : #define makeListo2(x1, x2)          list_make2_oid(x1, x2)
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            : #define lconsi(datum, list)         lcons_int(datum, list)
<span class="lineNum">     325 </span>            : #define lconso(datum, list)         lcons_oid(datum, list)
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : #define lappendi(list, datum)       lappend_int(list, datum)
<span class="lineNum">     328 </span>            : #define lappendo(list, datum)       lappend_oid(list, datum)
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : #define nconc(l1, l2)               list_concat(l1, l2)
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : #define nth(n, list)                list_nth(list, n)
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : #define member(datum, list)         list_member(list, datum)
<span class="lineNum">     335 </span>            : #define ptrMember(datum, list)      list_member_ptr(list, datum)
<span class="lineNum">     336 </span>            : #define intMember(datum, list)      list_member_int(list, datum)
<span class="lineNum">     337 </span>            : #define oidMember(datum, list)      list_member_oid(list, datum)
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : /*
<span class="lineNum">     340 </span>            :  * Note that the old lremove() determined equality via pointer
<span class="lineNum">     341 </span>            :  * comparison, whereas the new list_delete() uses equal(); in order to
<span class="lineNum">     342 </span>            :  * keep the same behavior, we therefore need to map lremove() calls to
<span class="lineNum">     343 </span>            :  * list_delete_ptr() rather than list_delete()
<span class="lineNum">     344 </span>            :  */
<span class="lineNum">     345 </span>            : #define lremove(elem, list)         list_delete_ptr(list, elem)
<span class="lineNum">     346 </span>            : #define LispRemove(elem, list)      list_delete(list, elem)
<span class="lineNum">     347 </span>            : #define lremovei(elem, list)        list_delete_int(list, elem)
<span class="lineNum">     348 </span>            : #define lremoveo(elem, list)        list_delete_oid(list, elem)
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : #define ltruncate(n, list)          list_truncate(list, n)
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            : #define set_union(l1, l2)           list_union(l1, l2)
<span class="lineNum">     353 </span>            : #define set_uniono(l1, l2)          list_union_oid(l1, l2)
<span class="lineNum">     354 </span>            : #define set_ptrUnion(l1, l2)        list_union_ptr(l1, l2)
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : #define set_difference(l1, l2)      list_difference(l1, l2)
<span class="lineNum">     357 </span>            : #define set_differenceo(l1, l2)     list_difference_oid(l1, l2)
<span class="lineNum">     358 </span>            : #define set_ptrDifference(l1, l2)   list_difference_ptr(l1, l2)
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            : #define equali(l1, l2)              equal(l1, l2)
<span class="lineNum">     361 </span>            : #define equalo(l1, l2)              equal(l1, l2)
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : #define freeList(list)              list_free(list)
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : #define listCopy(list)              list_copy(list)
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            : extern int  length(List *list);
<span class="lineNum">     368 </span>            : #endif                          /* ENABLE_LIST_COMPAT */
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            : #endif                          /* PG_LIST_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
