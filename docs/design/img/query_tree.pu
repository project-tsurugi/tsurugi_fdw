@startuml

CreateStmt "1" --> "1" RangeVar : relation
CreateStmt "1" --> "*" ColumnDef : tableElts
ColumnDef "1" --> "*" TypeName : typeName
List "1" --> "*" ListCell : head, tail
ListCell "1" --> "1" ListCell.data : data
CreateStmt "1" --> "*" Constraint : constraints
Constraint "1" --> "*" Value : keys
note on link : 制約が設定されたカラム名

Constraint "1" --> "0...1" A_Const : raw_expr

IndexStmt "1" --> "1" RangeVar : relation
IndexStmt "1" --> "*" IndexElem : indexParams

ColumnDef "1" --> "0...1" A_Const : raw_default
ColumnDef "1" --> "*" Constraint : constraints

TypeName "1" --> "*" Value : names
note on link : 型の修飾名のリスト

TypeName "1" --> "*" A_Const : typemods
A_Const "1" --> "1" Value : val
note on link : 文字列型の長さnは、val.val.ivalでアクセス

Value "1" --> "1" Value.val : val

class List{
	{field} NodeTag type; /* T_List, T_IntList, or T_OidList */
	{field} int length;
	{field} ListCell *head;
	{field} ListCell *tail;
}

class ListCell{
	{field} union data
	{field} ListCell *next
}

class ListCell.data {
	{field} void *ptr_value
	{field} int int_value
	{field} Oid oid_value
}

class IndexStmt{
	{field} NodeTag		type;
	{field} char	   *idxname;		/* name of new index, or NULL for default */
	{field} RangeVar   *relation;		/* relation to build index on */
	{field} Oid			relationId;		/* OID of relation to build index on */
	{field} char	   *accessMethod;	/* name of access method (eg. btree) */
	{field} char	   *tableSpace;		/* tablespace, or NULL for default */
	{field} List	   *indexParams;	/* columns to index: a list of IndexElem */
	{field} List	   *indexIncludingParams;	/* additional columns to index: a list of IndexElem */
	{field} List	   *options;		/* WITH clause options: a list of DefElem */
	{field} Node	   *whereClause;	/* qualification (partial-index predicate) */
	{field} List	   *excludeOpNames; /* exclusion operator names, or NIL if none */
	{field} char	   *idxcomment;		/* comment to apply to index, or NULL */
	{field} Oid			indexOid;		/* OID of an existing index, if any */
	{field} Oid			oldNode;		/* relfilenode of existing storage, if any */
	{field} bool		unique;			/* is index unique? */
	{field} bool		primary;		/* is index a primary key? */
	{field} bool		isconstraint;	/* is it for a pkey/unique constraint? */
	{field} bool		deferrable;		/* is the constraint DEFERRABLE? */
	{field} bool		initdeferred;	/* is the constraint INITIALLY DEFERRED? */
	{field} bool		transformed;	/* true when transformIndexStmt is finished */
	{field} bool		concurrent;		/* should this be a concurrent index build? */
	{field} bool		if_not_exists;	/* just do nothing if index already exists? */
}
note left of IndexStmt
This represents creation of an index and/or an associated constraint.
If isconstraint is true, we should create a pg_constraint entry along
with the index.  But if indexOid isn't InvalidOid, we are not creating an
index, just a UNIQUE/PKEY constraint using an existing index.  isconstraint
must always be true in this case, and the fields describing the index
properties are empty.

The relation to build the index on can be represented either by name
(in which case the RangeVar indicates whether to recurse or not) or by OID
(in which case the command is always recursive).
endnote


class IndexElem
{
	{field} NodeTag		type;
	{field} char	   *name;			/* name of attribute to index, or NULL */
	{field} Node	   *expr;			/* expression to index, or NULL */
	{field} char	   *indexcolname;	/* name for index column; NULL = default */
	{field} List	   *collation;		/* name of collation; NIL = default */
	{field} List	   *opclass;		/* name of desired opclass; NIL = default */
	{field} SortByDir	ordering;		/* ASC/DESC/default */
	{field} SortByNulls nulls_ordering; /* FIRST/LAST/default */
}

note left of IndexElem
IndexElem - index parameters (used in CREATE INDEX, and in ON CONFLICT)

For a plain index attribute, 'name' is the name of the table column to
index, and 'expr' is NULL.  For an index expression, 'name' is NULL and
'expr' is the expression tree.

ソートの例
ordering = SORTBY_DEFAULT
nulls_ordering = SORTBY_NULLS_DEFAULT
end note



class CreateStmt {
	{field} NodeTag		type;
	{field} RangeVar   *relation;		/* relation to create */
	{field} List	   *tableElts;		/* column definitions (list of ColumnDef) */
	{field} List	   *inhRelations;	/* relations to inherit from (list of inhRelation) */
	{field} PartitionBoundSpec *partbound;	/* FOR VALUES clause */
	{field} PartitionSpec *partspec;	/* PARTITION BY clause */
	{field} TypeName   *ofTypename;		/* OF typename */
	{field} List	   *constraints;	/* constraints (list of Constraint nodes) */
	{field} List	   *options;		/* options from WITH clause */
	{field} OnCommitAction oncommit;	/* what do we do at COMMIT? */
	{field} char	   *tablespacename; /* table space to use, or NULL */
	{field} bool		if_not_exists;	/* just do nothing if it already exists? */
}
note left of CreateStmt
NOTE: in the raw gram.y output, ColumnDef and Constraint nodes are
intermixed in tableElts, and constraints is NIL. After parse analysis,
tableElts contains just ColumnDefs, and constraints contains just
Constraint nodes (in fact, only CONSTR_CHECK nodes, in the present
implementation).
endnote

class RangeVar {
	{field} NodeTag		type;
	{field} char	   *catalogname;	/* the catalog (database) name, or NULL */
	{field} char	   *schemaname;		/* the schema name, or NULL */
	{field} char	 	*relname;
	{field} bool		inh;			/* expand rel by inheritance? recursively act on children? */
	{field} char		relpersistence; /* see RELPERSISTENCE_* in pg_class.h */
	{field} Alias	   *alias;			/* table alias & optional column aliases */
	{field} int			location;		/* token location, or -1 if unknown */
}
note right of RangeVar::relname;
the relation/sequence name
endnote

class ColumnDef {
	{field} NodeTag		type;
	{field} char	    *colname;
	{field} TypeName   *typeName;		/* type of column */
	{field} int			inhcount;		/* number of times column is inherited */
	{field} bool		is_local;		/* column has local (non-inherited) def'n */
	{field} bool		is_not_null;	/* NOT NULL constraint specified? */
	{field} bool		is_from_type;	/* column definition came from table type */
	{field} bool		is_from_parent; /* XXX unused */
	{field} char		storage;		/* attstorage setting, or 0 for default */
	{field} Node	   *raw_default;	/* default value (untransformed parse tree)*/
	{field} Node	   *cooked_default; /* default value (transformed expr tree)*/
	{field} char		identity;		/* attidentity setting */
	{field} RangeVar   *identitySequence;	/* to store identity sequence name for ALTER TABLE ... ADD COLUMN */
	{field} CollateClause *collClause;	/* untransformed COLLATE spec, if any */
	{field} Oid			collOid;		/* collation OID (InvalidOid if not set) */
	{field} List	   *constraints;	/* other constraints on column */
	{field} List	   *fdwoptions;		/* per-column FDW options */
	{field} int			location;		/* parse location, or -1 if none/unknown */
}
note right of ColumnDef::*colname;
  カラム名
endnote

class TypeName
{
    {field} NodeTag     type;
    {field} List       *names;          /* qualified name (list of Value strings)*/
    {field} Oid         typeOid;        /* type identified by OID */
    {field} bool        setof;          /* is a set? */
    {field} bool        pct_type;       /* %TYPE specified? */
    {field} List       *typmods;        /* type modifier expression(s)*/
    {field} int32       typemod;        /* prespecified type modifier */
    {field} List       *arrayBounds;
    {field} int         location;       /* token location, or -1 if unknown */
}

note right of TypeName
TypeName - specifies a type in definitions

For TypeName structures generated internally, it is often easier to
specify the type by OID than by name.  If "names" is NIL then the
actual type OID is given by typeOid, otherwise typeOid is unused.
Similarly, if "typmods" is NIL then the actual typmod is expected to
be prespecified in typemod, otherwise typemod is unused.

If pct_type is true, then names is actually a field name and we look up
the type of that field.  Otherwise (the normal case), names is a type
name possibly qualified with schema and database name.
endnote

note left of TypeName
次の型の長さnは、typemodsに格納
・charcter varying(n), varchar(n)
・charcter(n), char(n)
endnote

note left of TypeName::arrayBounds
array bounds
配列型が指定されたときに利用。
配列数分のListCellが格納される。ListCell内の値の意味は未調査。
endnote

class A_Const
{
	{field} NodeTag		type;
	{field} Value		val;			/* value (includes type info, see value.h) */
	{field} int			location;		/* token location, or -1 if unknown */
}

note right of A_Const
A_Const - a literal constant
endnote

class Value
{
	{field} NodeTag 	type
	{field} union 	val
}

class Value.val
{
	{field} int 	ival
	{field} char* 	str
}

class Constraint
{
	{field} NodeTag		type;
	{field} ConstrType	contype;

	{field} /* Fields used for most/all constraint types: */
	{field} char	   *conname;		/* Constraint name, or NULL if unnamed */
	{field} bool		deferrable;		/* DEFERRABLE? */
	{field} bool		initdeferred;	/* INITIALLY DEFERRED? */
	{field} int			location;		/* token location, or -1 if unknown */

	{field} /* Fields used for constraints with expressions (CHECK and DEFAULT): */
	{field} bool		is_no_inherit;	/* is constraint non-inheritable? */
	{field} Node	   *raw_expr;		/* expr, as untransformed parse tree */
	{field} char	   *cooked_expr;	/* expr, as nodeToString representation */
	{field} char		generated_when;

	{field} /* Fields used for unique constraints (UNIQUE and PRIMARY KEY): */
	{field} List	   *keys;			/* String nodes naming referenced key column(s) */
	{field} List	   *including;		/* String nodes naming referenced nonkey column(s) */

	{field} /* Fields used for EXCLUSION constraints: */
	{field} List	   *exclusions;		/* list of (IndexElem, operator name) pairs */

	{field} /* Fields used for index constraints (UNIQUE, PRIMARY KEY, EXCLUSION): */
	{field} List	   *options;		/* options from WITH clause */
	{field} char	   *indexname;		/* existing index to use; otherwise NULL */
	{field} char	   *indexspace;		/* index tablespace; NULL for default */

	{field} /* These could be, but currently are not, used for UNIQUE/PKEY: */
	{field} char	   *access_method;	/* index access method; NULL for default */
	{field} Node	   *where_clause;	/* partial index predicate */

	{field} /* Fields used for FOREIGN KEY constraints: */
	{field} RangeVar   *pktable;		/* Primary key table */
	{field} List	   *fk_attrs;		/* Attributes of foreign key */
	{field} List	   *pk_attrs;		/* Corresponding attrs in PK table */
	{field} char		fk_matchtype;	/* FULL, PARTIAL, SIMPLE */
	{field} char		fk_upd_action;	/* ON UPDATE action */
	{field} char		fk_del_action;	/* ON DELETE action */
	{field} List	   *old_conpfeqop;	/* pg_constraint.conpfeqop of my former self */
	{field} Oid			old_pktable_oid;	/* pg_constraint.confrelid of my former self */

	{field} /* Fields used for constraints that allow a NOT VALID specification */
	{field} bool		skip_validation;	/* skip validation of existing rows? */
	{field} bool		initially_valid;	/* mark the new constraint as valid? */
}

note left of Constraint
/* ----------
 * Definitions for constraints in CreateStmt
 *
 * Note that column defaults are treated as a type of constraint,
 * even though that's a bit odd semantically.
 *
 * For constraints that use expressions (CONSTR_CHECK, CONSTR_DEFAULT)
 * we may have the expression in either "raw" form (an untransformed
 * parse tree) or "cooked" form (the nodeToString representation of
 * an executable expression tree), depending on how this Constraint
 * node was created (by parsing, or by inheritance from an existing
 * relation).  We should never have both in the same node!
 *
 * FKCONSTR_ACTION_xxx values are stored into pg_constraint.confupdtype
 * and pg_constraint.confdeltype columns; FKCONSTR_MATCH_xxx values are
 * stored into pg_constraint.confmatchtype.  Changing the code values may
 * require an initdb!
 *
 * If skip_validation is true then we skip checking that the existing rows
 * in the table satisfy the constraint, and just install the catalog entries
 * for the constraint.  A new FK constraint is marked as valid iff
 * initially_valid is true.  (Usually skip_validation and initially_valid
 * are inverses, but we can set both true if the table is known empty.)
 *
 * Constraint attributes (DEFERRABLE etc) are initially represented as
 * separate Constraint nodes for simplicity of parsing.  parse_utilcmd.c makes
 * a pass through the constraints list to insert the info into the appropriate
 * Constraint node.
 * ----------
 */

/* Foreign key action codes */
#define FKCONSTR_ACTION_NOACTION	'a'
#define FKCONSTR_ACTION_RESTRICT	'r'
#define FKCONSTR_ACTION_CASCADE		'c'
#define FKCONSTR_ACTION_SETNULL		'n'
#define FKCONSTR_ACTION_SETDEFAULT	'd'

/* Foreign key matchtype codes */
#define FKCONSTR_MATCH_FULL			'f'
#define FKCONSTR_MATCH_PARTIAL		'p'
#define FKCONSTR_MATCH_SIMPLE		's'

endnote

note left of Constraint::contype;
	CONSTR_NULL,				/* not standard SQL, but a lot of people expect it */
	CONSTR_NOTNULL,
	CONSTR_DEFAULT,           /* DEFAULT句が指定されたとき、Constraintに指定される*/
	CONSTR_IDENTITY,
	CONSTR_CHECK,
	CONSTR_PRIMARY,
	CONSTR_UNIQUE,
	CONSTR_EXCLUSION,
	CONSTR_FOREIGN,
	CONSTR_ATTR_DEFERRABLE,		/* attributes for previous constraint node */
	CONSTR_ATTR_NOT_DEFERRABLE,
	CONSTR_ATTR_DEFERRED,
	CONSTR_ATTR_IMMEDIATE
endnote


@enduml
